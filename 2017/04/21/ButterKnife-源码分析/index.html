<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://yoursite.com">
  <title>ButterKnife 源码分析 | 苟利国家生死已 岂因祸福避趋之</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="相信现在所有做安卓开发的朋友没有没听说过ButterKnife这个库的吧。一个由大名鼎鼎的Square公司的更大名鼎鼎的JakeWharton开发的一个基于注解的注入库。可以帮助我们省去烦人的findViewById和setOnclickListener等模板代码。具体用法不细讲了，有需要的朋友可以去查阅官方文档，今天主要来分析下它的代码和执行流程。
首先下载源码并打开后，可以看到整个工程的组织结">
<meta property="og:type" content="article">
<meta property="og:title" content="ButterKnife 源码分析">
<meta property="og:url" content="http://yoursite.com/2017/04/21/ButterKnife-源码分析/index.html">
<meta property="og:site_name" content="苟利国家生死已 岂因祸福避趋之">
<meta property="og:description" content="相信现在所有做安卓开发的朋友没有没听说过ButterKnife这个库的吧。一个由大名鼎鼎的Square公司的更大名鼎鼎的JakeWharton开发的一个基于注解的注入库。可以帮助我们省去烦人的findViewById和setOnclickListener等模板代码。具体用法不细讲了，有需要的朋友可以去查阅官方文档，今天主要来分析下它的代码和执行流程。
首先下载源码并打开后，可以看到整个工程的组织结">
<meta property="og:updated_time" content="2017-04-21T09:00:34.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ButterKnife 源码分析">
<meta name="twitter:description" content="相信现在所有做安卓开发的朋友没有没听说过ButterKnife这个库的吧。一个由大名鼎鼎的Square公司的更大名鼎鼎的JakeWharton开发的一个基于注解的注入库。可以帮助我们省去烦人的findViewById和setOnclickListener等模板代码。具体用法不细讲了，有需要的朋友可以去查阅官方文档，今天主要来分析下它的代码和执行流程。
首先下载源码并打开后，可以看到整个工程的组织结">
  
    <link rel="alternative" href="/atom.xml" title="苟利国家生死已 岂因祸福避趋之" type="application/atom+xml">
  
  
    <link rel="icon" href="https://avatars2.githubusercontent.com/u/5449200?v=3&s=460">
  
  <link rel="stylesheet" href="/main.css">
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="null" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">fkaking</a></h1>
		</hgroup>

		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/fkaking" title="github">github</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">fkaking</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="null" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">fkaking</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/fkaking" title="github">github</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        <article id="post-ButterKnife-源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      ButterKnife 源码分析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>相信现在所有做安卓开发的朋友没有没听说过<a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a>这个库的吧。一个由大名鼎鼎的Square公司的更大名鼎鼎的JakeWharton开发的一个基于注解的注入库。可以帮助我们省去烦人的findViewById和setOnclickListener等模板代码。具体用法不细讲了，有需要的朋友可以去查阅官方文档，今天主要来分析下它的代码和执行流程。</p>
<p>首先下载源码并打开后，可以看到整个工程的组织结构。主要的模块有三个，分别是butterknife、butterknife-annotations、butterknife-compiler，另外还有几个库分别是test和lint（说到这不得不佩服老外做开源的精神。。。）今天主要做的分析就是针对这三个模块。我们一个个来。</p>
<h1 id="ButterKnife"><a href="#ButterKnife" class="headerlink" title="ButterKnife"></a>ButterKnife</h1><p>这个模块是使用butterknife的用户直接使用的。比如我们在Activity里bindview，那就要调用一个ButterKnife.bind(this)方法。只要有了这句，就可以开始搞黑科技了。那么bind方法到底做了什么呢？上代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@NonNull</span> <span class="meta">@UiThread</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unbinder <span class="title">bind</span><span class="params">(@NonNull Activity target)</span> </span>&#123;</div><div class="line">  View sourceView = target.getWindow().getDecorView();</div><div class="line">  <span class="keyword">return</span> createBinding(target, sourceView);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>bind方法里调用了createBinding()，那么来看看createBinding()都干了啥。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Unbinder <span class="title">createBinding</span><span class="params">(@NonNull Object target, @NonNull View source)</span> </span>&#123;</div><div class="line">  Class&lt;?&gt; targetClass = target.getClass();</div><div class="line">  <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"Looking up binding for "</span> + targetClass.getName());</div><div class="line">  Constructor&lt;? extends Unbinder&gt; constructor = findBindingConstructorForClass(targetClass);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (constructor == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">return</span> Unbinder.EMPTY;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//noinspection TryWithIdenticalCatches Resolves to API 19+ only type.</span></div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">return</span> constructor.newInstance(target, source);</div><div class="line">  &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to invoke "</span> + constructor, e);</div><div class="line">  &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to invoke "</span> + constructor, e);</div><div class="line">  &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</div><div class="line">    Throwable cause = e.getCause();</div><div class="line">    <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</div><div class="line">      <span class="keyword">throw</span> (RuntimeException) cause;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</div><div class="line">      <span class="keyword">throw</span> (Error) cause;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to create binding instance."</span>, cause);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，该方法里只做了一件事，那就是找到对应Activity的binding对象的constructor方法，并且通过反射创建一个binding对象实例出来。那么Constructor对象又是怎么来的呢？我们来看findBindingConstructorForClass这个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@Nullable @CheckResult @UiThread</div><div class="line">private static Constructor&lt;? extends Unbinder&gt; findBindingConstructorForClass(Class&lt;?&gt; cls) &#123;</div><div class="line">  Constructor&lt;? extends Unbinder&gt; bindingCtor = BINDINGS.get(cls);</div><div class="line">  if (bindingCtor != null) &#123;</div><div class="line">    if (debug) Log.d(TAG, &quot;HIT: Cached in binding map.&quot;);</div><div class="line">    return bindingCtor;</div><div class="line">  &#125;</div><div class="line">  String clsName = cls.getName();</div><div class="line">  if (clsName.startsWith(&quot;android.&quot;) || clsName.startsWith(&quot;java.&quot;)) &#123;</div><div class="line">    if (debug) Log.d(TAG, &quot;MISS: Reached framework class. Abandoning search.&quot;);</div><div class="line">    return null;</div><div class="line">  &#125;</div><div class="line">  try &#123;</div><div class="line">    Class&lt;?&gt; bindingClass = cls.getClassLoader().loadClass(clsName + &quot;_ViewBinding&quot;);</div><div class="line">    //noinspection unchecked</div><div class="line">    bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.getConstructor(cls, View.class);</div><div class="line">    if (debug) Log.d(TAG, &quot;HIT: Loaded binding class and constructor.&quot;);</div><div class="line">  &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">    if (debug) Log.d(TAG, &quot;Not found. Trying superclass &quot; + cls.getSuperclass().getName());</div><div class="line">    bindingCtor = findBindingConstructorForClass(cls.getSuperclass());</div><div class="line">  &#125; catch (NoSuchMethodException e) &#123;</div><div class="line">    throw new RuntimeException(&quot;Unable to find binding constructor for &quot; + clsName, e);</div><div class="line">  &#125;</div><div class="line">  BINDINGS.put(cls, bindingCtor);</div><div class="line">  return bindingCtor;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先到BINDINGS这个缓存map里寻找对应class的constructor对象，如果没有找到，则通过反射去创建。但由于反射对性能有一定影响，所以在首次反射成功后，就把结果放到缓存里。<code>Class&lt;?&gt; bindingClass = cls.getClassLoader().loadClass(clsName + &quot;_ViewBinding&quot;);</code>可以看到对应的bingview类的名字是原Activity的名字加上<code>_ViewBinding</code>构成的。这一点可以从我们编译后的代码里验证。打开app/build/generated/apt目录，可以看到所有我们注入的类在这里都有一个对应的’_ViewBinding’的java文件。这个文件就是butterknife通过apt自动生成的代码。</p>
<p>那么这个_ViewBinding文件里到底做了些什么呢？我们打开一个看看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class SearchActivity_ViewBinding&lt;T extends SearchActivity&gt; implements Unbinder &#123;</div><div class="line">  protected T target;</div><div class="line"></div><div class="line">  private View view2131690696;</div><div class="line"></div><div class="line">  @UiThread</div><div class="line">  public SearchActivity_ViewBinding(final T target, View source) &#123;</div><div class="line">    this.target = target;</div><div class="line"></div><div class="line">    View view;</div><div class="line">    target.defaultView = Utils.findRequiredViewAsType(source, R.id.default_view, &quot;field &apos;defaultView&apos;&quot;, RelativeLayout.class);</div><div class="line">    view = Utils.findRequiredView(source, R.id.create_record, &quot;method &apos;onClick&apos;&quot;);</div><div class="line">    view2131690696 = view;</div><div class="line">    view.setOnClickListener(new DebouncingOnClickListener() &#123;</div><div class="line">      @Override</div><div class="line">      public void doClick(View p0) &#123;</div><div class="line">        target.onClick();</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override</div><div class="line">  @CallSuper</div><div class="line">  public void unbind() &#123;</div><div class="line">    T target = this.target;</div><div class="line">    if (target == null) throw new IllegalStateException(&quot;Bindings already cleared.&quot;);</div><div class="line"></div><div class="line">    target.defaultView = null;</div><div class="line"></div><div class="line">    view2131690696.setOnClickListener(null);</div><div class="line">    view2131690696 = null;</div><div class="line"></div><div class="line">    this.target = null;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原来就是一个实现了Unbinder接口的类。Unbinder接口只有一个unbind方法，主要工作是把注入的元素和监听事件解绑，比较简单。重点来看这个类的构造方法。首先我们可以看到一个名为target的成员变量，这个通过上下文我们可以猜到它就是我们被注入的Activity对象。构造方法里执行了几个赋值的语句，因为我在原Activity的defaultView这个变量上添加了注解，那么这里给activity.targetView赋值，就是所谓的注入过程。这也就解释了为什么被注解标识的元素不能用private修饰的原因。</p>
<p>其实说到这，我们基本上就看懂ButterKnife的实现原理了。首先，当我们在开发过程中对某些元素添加注解后，进行编译，编译的过程中ButterKnife会生成对应的_ViewBinding的源文件，然后在代码运行过程中，通过调用ButterKnife.bind()方法，创建一个viewbinding对象（首次创建是反射的方式），这个viewbinding对象的构造方法里就执行了注入。所以在创建对象的过程中也就是执行bind方法时，就为Activity里的变量完成了注入。此时，我们就可以随心所欲的使用声明了的view变量了，省去了为view手动赋值的过程。</p>
<p>是不是很简单？哈哈，说起来简单，其实背后的工作很复杂。比如刚才说到ButterKnife自动生成源文件，这其实是个很繁琐的过程，别急，一会儿会讲到。</p>
<h2 id="Annotations"><a href="#Annotations" class="headerlink" title="Annotations"></a>Annotations</h2><p>在讲生成源代码之前，我们先来了解下注解这个东西。java的注解位于java.lang.annotation包下。</p>
<p>ButterKnife里定义了很多注解，我们找一个来看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Retention(CLASS) @Target(FIELD)</div><div class="line">public @interface BindView &#123;</div><div class="line">  /** View ID to which the field will be bound. */</div><div class="line">  @IdRes int value();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个是我们最常用的BindView注解，它的定义如上。</p>
<p>注解用@interface来表示。在上面还有@Retention和@Target</p>
<ul>
<li>@Retention 表示注解存在的生命周期。它有三个对应值，分别是SOURCE（源码期）、CLASS（编译期）、RUNTIME（运行期）。</li>
<li>@Target 表示该注解可以用来修饰哪些元素。这里FILED表示所有的成员变量都可以使用这个注解。</li>
</ul>
<p>接口还定义了一个value方法，返回的是对应view的id，也就是我们在写注解时@BindView(R.id.**)括号里的内容。</p>
<h2 id="Annotation-Processor"><a href="#Annotation-Processor" class="headerlink" title="Annotation Processor"></a>Annotation Processor</h2><p>注解有了，我们也知道工作原理了，那么目前还有一个问题没搞清楚，butterknife是怎么创造出这些源文件的呢？而且里面还是标准的java代码！这就不得不请另一位重量级嘉宾出场了——Annotation Processor。也就是注解处理器。注解处理器是<strong>javac</strong>的一个工具，它用来在编译时扫描和处理注解（Annotation）。你可以对自定义注解，并注册相应的注解处理器。到这里，我们已经知道什么是注解，并且知道怎么申明的一个注解。如果相对注解有更深入的了解，你可以在这<a href="http://docs.oracle.com/javase/tutorial/java/annotations/index.html" target="_blank" rel="external">官方文档</a>中得到更多信息。注解处理器在Java 5开始就有了，但是从Java 6（2006年12月发布）开始才有可用的API。过了一些时间，Java世界才意识到注解处理器的强大作用，所以它到最近几年才流行起来。</p>
<p>一个注解的注解处理器，以Java代码（或者编译过的字节码）作为输入，生成文件（通常是<code>.java</code>文件）作为输出。这具体的含义什么呢？你可以生成Java代码！这些生成的Java代码是在生成的.java文件中，所以你不能修改已经存在的Java类，例如向已有的类中添加方法。这些生成的Java文件，会同其他普通的手动编写的Java源代码一样被<strong>javac</strong>编译。</p>
<p>ButterKnife为了实现注入功能，为每一个含有注解的类都自动生成了一份_ViewBinding文件，为此也定义了自己的Annotation Processor。其代码位于butterknife/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java。</p>
<p>具体应该如何实现一个Processor这里不展开讲，有时间专门写一篇。我们只关注它的核心部分：process方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@Override public boolean process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env) &#123;</div><div class="line">  Map&lt;TypeElement, BindingSet&gt; bindingMap = findAndParseTargets(env);</div><div class="line"></div><div class="line">  for (Map.Entry&lt;TypeElement, BindingSet&gt; entry : bindingMap.entrySet()) &#123;</div><div class="line">    TypeElement typeElement = entry.getKey();</div><div class="line">    BindingSet binding = entry.getValue();</div><div class="line"></div><div class="line">    JavaFile javaFile = binding.brewJava(sdk);</div><div class="line">    try &#123;</div><div class="line">      javaFile.writeTo(filer);</div><div class="line">    &#125; catch (IOException e) &#123;</div><div class="line">      error(typeElement, &quot;Unable to write binding for type %s: %s&quot;, typeElement, e.getMessage());</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总体来看 <code>process</code> 方法就干了两件事情：</p>
<ol>
<li>扫描所有的注解，然后生成以 <code>TypeElement</code> 为 key ，<code>BindingSet</code> 为 value 的 Map ；</li>
<li>根据生成的 Map ，遍历后通过 Filter 来生成对应的辅助类源码。PS：<a href="http://yuqirong.me/2016/12/18/ButterKnife%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank" rel="external">ButterKnife</a> 使用了 <a href="https://github.com/square/javapoet" target="_blank" rel="external">JavaPoet</a> 来生成 Java 源码。如果对 <a href="https://github.com/square/javapoet" target="_blank" rel="external">JavaPoet</a> 不太熟悉，可以先阅读这篇文章 <a href="http://www.jianshu.com/p/95f12f72f69a" target="_blank" rel="external">《javapoet——让你从重复无聊的代码中解放出来》</a> 。</li>
</ol>
<p>先来分析一下 <code>findAndParseTargets(env)</code> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// 扫描所有的ButterKnife注解，并且生成以TypeElement为键，BindingSet为值的HashMap</div><div class="line">private Map&lt;TypeElement, BindingSet&gt; findAndParseTargets(RoundEnvironment env) &#123;</div><div class="line">	Map&lt;TypeElement, BindingSet.Builder&gt; builderMap = new LinkedHashMap&lt;&gt;();</div><div class="line">	Set&lt;TypeElement&gt; erasedTargetNames = new LinkedHashSet&lt;&gt;();</div><div class="line">	</div><div class="line">	scanForRClasses(env);</div><div class="line"></div><div class="line">	// Process each @BindView element.</div><div class="line">	// 遍历所有被 @BindView 标注的元素</div><div class="line">	for (Element element : env.getElementsAnnotatedWith(BindView.class)) &#123;</div><div class="line">	  // we don&apos;t SuperficialValidation.validateElement(element)</div><div class="line">	  // so that an unresolved View type can be generated by later processing rounds</div><div class="line">	  try &#123;</div><div class="line">	    parseBindView(element, builderMap, erasedTargetNames);</div><div class="line">	  &#125; catch (Exception e) &#123;</div><div class="line">	    logParsingError(element, BindView.class, e);</div><div class="line">	  &#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	... </div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先来看关于 <code>BindView</code> 的那个 for 循环，它会遍历所有被 <code>@BindView</code> 注解的属性，然后调用 <code>parseBindView</code>方法。那么我们就先看到 <code>findAndParseTargets</code> 的前半段，一起跟进 <code>parseBindView</code> 的方法中去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">private void parseBindView(Element element, Map&lt;TypeElement, BindingSet.Builder&gt; builderMap,</div><div class="line">    Set&lt;TypeElement&gt; erasedTargetNames) &#123;</div><div class="line">  TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();</div><div class="line"></div><div class="line">  // Start by verifying common generated code restrictions.</div><div class="line">  boolean hasError = isInaccessibleViaGeneratedCode(BindView.class, &quot;fields&quot;, element)</div><div class="line">      || isBindingInWrongPackage(BindView.class, element);</div><div class="line"></div><div class="line">  // Verify that the target type extends from View.</div><div class="line">  TypeMirror elementType = element.asType();</div><div class="line">  if (elementType.getKind() == TypeKind.TYPEVAR) &#123;</div><div class="line">    TypeVariable typeVariable = (TypeVariable) elementType;</div><div class="line">    elementType = typeVariable.getUpperBound();</div><div class="line">  &#125;</div><div class="line">  Name qualifiedName = enclosingElement.getQualifiedName();</div><div class="line">  Name simpleName = element.getSimpleName();</div><div class="line">  if (!isSubtypeOfType(elementType, VIEW_TYPE) &amp;&amp; !isInterface(elementType)) &#123;</div><div class="line">    if (elementType.getKind() == TypeKind.ERROR) &#123;</div><div class="line">      note(element, &quot;@%s field with unresolved type (%s) &quot;</div><div class="line">              + &quot;must elsewhere be generated as a View or interface. (%s.%s)&quot;,</div><div class="line">          BindView.class.getSimpleName(), elementType, qualifiedName, simpleName);</div><div class="line">    &#125; else &#123;</div><div class="line">      error(element, &quot;@%s fields must extend from View or be an interface. (%s.%s)&quot;,</div><div class="line">          BindView.class.getSimpleName(), qualifiedName, simpleName);</div><div class="line">      hasError = true;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if (hasError) &#123;</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // Assemble information on the field.</div><div class="line">  int id = element.getAnnotation(BindView.class).value();</div><div class="line"></div><div class="line">  BindingSet.Builder builder = builderMap.get(enclosingElement);</div><div class="line">  QualifiedId qualifiedId = elementToQualifiedId(element, id);</div><div class="line">  if (builder != null) &#123;</div><div class="line">    String existingBindingName = builder.findExistingBindingName(getId(qualifiedId));</div><div class="line">    if (existingBindingName != null) &#123;</div><div class="line">      error(element, &quot;Attempt to use @%s for an already bound ID %d on &apos;%s&apos;. (%s.%s)&quot;,</div><div class="line">          BindView.class.getSimpleName(), id, existingBindingName,</div><div class="line">          enclosingElement.getQualifiedName(), element.getSimpleName());</div><div class="line">      return;</div><div class="line">    &#125;</div><div class="line">  &#125; else &#123;</div><div class="line">    builder = getOrCreateBindingBuilder(builderMap, enclosingElement);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  String name = simpleName.toString();</div><div class="line">  TypeName type = TypeName.get(elementType);</div><div class="line">  boolean required = isFieldRequired(element);</div><div class="line"></div><div class="line">  builder.addField(getId(qualifiedId), new FieldViewBinding(name, type, required));</div><div class="line"></div><div class="line">  // Add the type-erased version to the valid binding targets set.</div><div class="line">  erasedTargetNames.add(enclosingElement);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先对每个element做了类型校验，然后去创建bindingbuilder。builder中有相应的变量信息，后面会用到这些信息去生成代码。</p>
<p>接下来我们继续看findAndParseTargets方法的后半段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">private Map&lt;TypeElement, BindingSet&gt; findAndParseTargets(RoundEnvironment env) &#123;</div><div class="line"></div><div class="line">	... // 省略前半部分源码</div><div class="line"></div><div class="line">	// Associate superclass binders with their subclass binders. This is a queue-based tree walk</div><div class="line">	// which starts at the roots (superclasses) and walks to the leafs (subclasses).</div><div class="line">	Deque&lt;Map.Entry&lt;TypeElement, BindingSet.Builder&gt;&gt; entries =</div><div class="line">	    new ArrayDeque&lt;&gt;(builderMap.entrySet());</div><div class="line">	Map&lt;TypeElement, BindingSet&gt; bindingMap = new LinkedHashMap&lt;&gt;();</div><div class="line">	while (!entries.isEmpty()) &#123;</div><div class="line">	  // 一个个取出遍历</div><div class="line">	  Map.Entry&lt;TypeElement, BindingSet.Builder&gt; entry = entries.removeFirst();</div><div class="line">	  // 得到对应的 key 和 value</div><div class="line">	  TypeElement type = entry.getKey();</div><div class="line">	  BindingSet.Builder builder = entry.getValue();</div><div class="line">	  // 找到该类元素的父元素</div><div class="line">	  TypeElement parentType = findParentType(type, erasedTargetNames);</div><div class="line">	  if (parentType == null) &#123;</div><div class="line">	    // 生成 BindingSet ，放入 Map 中</div><div class="line">	    bindingMap.put(type, builder.build());</div><div class="line">	  &#125; else &#123;</div><div class="line">	    BindingSet parentBinding = bindingMap.get(parentType);</div><div class="line">	    if (parentBinding != null) &#123;</div><div class="line">	      // 设置父元素的 BindingSet</div><div class="line">	      builder.setParent(parentBinding);</div><div class="line">	      bindingMap.put(type, builder.build());</div><div class="line">	    &#125; else &#123;</div><div class="line">	      // Has a superclass binding but we haven&apos;t built it yet. Re-enqueue for later.</div><div class="line">	      // 有父元素，但是父元素的 BindingSet 还没有被 build 出来，</div><div class="line">	      // 所以再放入 entries 中等待遍历 </div><div class="line">	      entries.addLast(entry);</div><div class="line">	    &#125;</div><div class="line">	  &#125;</div><div class="line">	&#125;</div><div class="line">	// 解析结果都会存放在 bindingMap 中</div><div class="line">	return bindingMap;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>findAndParseTargets(env)</code> 方法的后半段中，主要就是把之前的 <code>builderMap</code> 转换为了 <code>bindingMap</code> 并返回。</p>
<p>到了这里，我们把 <code>process(Set elements, RoundEnvironment env)</code> 做的第一件事情搞清楚了，下面就接着来看第二件事情了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 遍历 bindingMap 并且通过 Filer 生成 Java 代码</div><div class="line">for (Map.Entry&lt;TypeElement, BindingSet&gt; entry : bindingMap.entrySet()) &#123;</div><div class="line">  TypeElement typeElement = entry.getKey();</div><div class="line">  BindingSet binding = entry.getValue();</div><div class="line"></div><div class="line">  JavaFile javaFile = binding.brewJava(sdk);</div><div class="line">  try &#123;</div><div class="line">    javaFile.writeTo(filer);</div><div class="line">  &#125; catch (IOException e) &#123;</div><div class="line">    error(typeElement, &quot;Unable to write binding for type %s: %s&quot;, typeElement, e.getMessage());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="brewJava-int-sdk"><a href="#brewJava-int-sdk" class="headerlink" title="brewJava(int sdk)"></a>brewJava(int sdk)</h2><p>从上面可以看到，遍历了之前得到的 <code>bindingMap</code> ，然后利用 <code>binding</code> 中的信息生成相应的 Java 源码。所以在 <code>binding.brewJava(sdk)</code> 这个方法是我们重点关注对象。那么就进入 <code>BindingSet</code> (路径：butterknife-compiler/butterknife/compiler/BindingSet.java) 这个类中去看看吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">JavaFile brewJava(int sdk) &#123;</div><div class="line">    // 生成 JavaFile，添加相应的注释</div><div class="line">    return JavaFile.builder(bindingClassName.packageName(), createType(sdk))</div><div class="line">            .addFileComment(&quot;Generated code from Butter Knife. Do not modify!&quot;)</div><div class="line">            .build();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>brewJava(int sdk)</code> 方法的代码竟然这么短 O_o ，就是利用了 <code>JavaFile.builder</code> 生成了一个 <code>JavaFile</code> 对象而已。但是我们发现其中有一个 <code>createType(int sdk)</code> 方法，隐隐约约感觉一定是这个方法在搞大事情。继续跟进去看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">private TypeSpec createType(int sdk) &#123;</div><div class="line">    // 生成类名为 bindingClassName 的公共类，比如 MainActivity_ViewBinding</div><div class="line">    TypeSpec.Builder result = TypeSpec.classBuilder(bindingClassName.simpleName())</div><div class="line">            .addModifiers(PUBLIC);</div><div class="line">    // 是否修饰为 final ，默认是 false</div><div class="line">    if (isFinal) &#123;</div><div class="line">        result.addModifiers(FINAL);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (parentBinding != null) &#123;</div><div class="line">        // 如果有父类的话，那么要继承父类</div><div class="line">        result.superclass(parentBinding.bindingClassName);</div><div class="line">    &#125; else &#123;</div><div class="line">        // 如果没有父类，那么实现 Unbinder 接口</div><div class="line">        result.addSuperinterface(UNBINDER);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 增加一个变量名为target，类型为targetTypeName的成员变量</div><div class="line">    if (hasTargetField()) &#123;</div><div class="line">        result.addField(targetTypeName, &quot;target&quot;, PRIVATE);</div><div class="line">    &#125;</div><div class="line">    // 如果没有 View 绑定</div><div class="line">    if (!constructorNeedsView()) &#123;</div><div class="line">        // Add a delegating constructor with a target type + view signature for reflective use.</div><div class="line">        // 该生成的构造方法被 @deprecated ，一般作为反射使用</div><div class="line">        result.addMethod(createBindingViewDelegateConstructor(targetTypeName));</div><div class="line">    &#125;</div><div class="line">    // 生成构造方法，另外 findViewById 类似的代码都在这里生成</div><div class="line">    // Xxxx_ViewBinding 一般都是执行这个方法生成构造器</div><div class="line">    result.addMethod(createBindingConstructor(targetTypeName, sdk));</div><div class="line"></div><div class="line">    if (hasViewBindings() || parentBinding == null) &#123;</div><div class="line">        //生成unBind方法</div><div class="line">        result.addMethod(createBindingUnbindMethod(result, targetTypeName));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return result.build();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>createType(int sdk)</code> 方法中，基本构建好了一个类的大概，其中对于构造器以及类似 <code>findViewById</code> 的操作都是在 <code>createBindingConstructor(targetTypeName, sdk)</code> 中实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">private MethodSpec createBindingConstructor(TypeName targetType, int sdk) &#123;</div><div class="line">    // 创建构造方法，方法修饰符为 public ，并且添加注解为UiThread</div><div class="line">    MethodSpec.Builder constructor = MethodSpec.constructorBuilder()</div><div class="line">            .addAnnotation(UI_THREAD)</div><div class="line">            .addModifiers(PUBLIC);</div><div class="line">    // 如果有方法绑定，比如 @OnClick</div><div class="line">    if (hasMethodBindings()) &#123;</div><div class="line">        // 如果有，那么添加 targetType 类型，final 修饰，参数名为 target 的构造方法参数</div><div class="line">        constructor.addParameter(targetType, &quot;target&quot;, FINAL);</div><div class="line">    &#125; else &#123;</div><div class="line">        // 如果没有，和上面比起来就少了一个 final 修饰符</div><div class="line">        constructor.addParameter(targetType, &quot;target&quot;);</div><div class="line">    &#125;</div><div class="line">    // 如果有注解的 View</div><div class="line">    if (constructorNeedsView()) &#123;</div><div class="line">        // 那么添加 View source 参数</div><div class="line">        constructor.addParameter(VIEW, &quot;source&quot;);</div><div class="line">    &#125; else &#123;</div><div class="line">        // 否则添加 Context context 参数</div><div class="line">        constructor.addParameter(CONTEXT, &quot;context&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (hasUnqualifiedResourceBindings()) &#123;</div><div class="line">        // Aapt can change IDs out from underneath us, just suppress since all will work at runtime.</div><div class="line">        constructor.addAnnotation(AnnotationSpec.builder(SuppressWarnings.class)</div><div class="line">                .addMember(&quot;value&quot;, &quot;$S&quot;, &quot;ResourceType&quot;)</div><div class="line">                .build());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果有父类，那么会根据不同情况调用不同的 super 语句</div><div class="line">    if (parentBinding != null) &#123;</div><div class="line">        if (parentBinding.constructorNeedsView()) &#123;</div><div class="line">            constructor.addStatement(&quot;super(target, source)&quot;);</div><div class="line">        &#125; else if (constructorNeedsView()) &#123;</div><div class="line">            constructor.addStatement(&quot;super(target, source.getContext())&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">            constructor.addStatement(&quot;super(target, context)&quot;);</div><div class="line">        &#125;</div><div class="line">        constructor.addCode(&quot;\n&quot;);</div><div class="line">    &#125;</div><div class="line">    // 如果有绑定 Field 或者方法，那么添加 this.target = target 语句</div><div class="line">    if (hasTargetField()) &#123;</div><div class="line">        constructor.addStatement(&quot;this.target = target&quot;);</div><div class="line">        constructor.addCode(&quot;\n&quot;);</div><div class="line">    &#125;</div><div class="line">    // 如果有 View 绑定</div><div class="line">    if (hasViewBindings()) &#123;</div><div class="line">        if (hasViewLocal()) &#123;</div><div class="line">            // Local variable in which all views will be temporarily stored.</div><div class="line">            constructor.addStatement(&quot;$T view&quot;, VIEW);</div><div class="line">        &#125;</div><div class="line">        for (ViewBinding binding : viewBindings) &#123;</div><div class="line">            // 为 View 绑定生成类似于 findViewById 之类的代码</div><div class="line">            addViewBinding(constructor, binding);</div><div class="line">        &#125;</div><div class="line">        // 为 View 的集合或者数组绑定</div><div class="line">        for (FieldCollectionViewBinding binding : collectionBindings) &#123;</div><div class="line">            constructor.addStatement(&quot;$L&quot;, binding.render());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (!resourceBindings.isEmpty()) &#123;</div><div class="line">            constructor.addCode(&quot;\n&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 绑定 resource 资源的代码</div><div class="line">    if (!resourceBindings.isEmpty()) &#123;</div><div class="line">        if (constructorNeedsView()) &#123;</div><div class="line">            constructor.addStatement(&quot;$T context = source.getContext()&quot;, CONTEXT);</div><div class="line">        &#125;</div><div class="line">        if (hasResourceBindingsNeedingResource(sdk)) &#123;</div><div class="line">            constructor.addStatement(&quot;$T res = context.getResources()&quot;, RESOURCES);</div><div class="line">        &#125;</div><div class="line">        for (ResourceBinding binding : resourceBindings) &#123;</div><div class="line">            constructor.addStatement(&quot;$L&quot;, binding.render(sdk));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return constructor.build();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过上面的代码就生成了构造器，但是我们还是没有看到具体 <code>findViewById</code> 操作的代码。别急，这些代码都在 <code>addViewBinding(constructor, binding)</code> 里会看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">private void addViewBinding(MethodSpec.Builder result, ViewBinding binding) &#123;</div><div class="line">    if (binding.isSingleFieldBinding()) &#123;</div><div class="line">        // Optimize the common case where there&apos;s a single binding directly to a field.</div><div class="line">        FieldViewBinding fieldBinding = binding.getFieldBinding();</div><div class="line">        // 注意这里直接使用了 target. 的形式，所以属性肯定是不能 private 的</div><div class="line">        CodeBlock.Builder builder = CodeBlock.builder()</div><div class="line">                .add(&quot;target.$L = &quot;, fieldBinding.getName());</div><div class="line">        // 下面都是 View 绑定的代码</div><div class="line">        boolean requiresCast = requiresCast(fieldBinding.getType());</div><div class="line">        if (!requiresCast &amp;&amp; !fieldBinding.isRequired()) &#123;</div><div class="line">            builder.add(&quot;source.findViewById($L)&quot;, binding.getId().code);</div><div class="line">        &#125; else &#123;</div><div class="line">            builder.add(&quot;$T.find&quot;, UTILS);</div><div class="line">            builder.add(fieldBinding.isRequired() ? &quot;RequiredView&quot; : &quot;OptionalView&quot;);</div><div class="line">            if (requiresCast) &#123;</div><div class="line">                builder.add(&quot;AsType&quot;);</div><div class="line">            &#125;</div><div class="line">            builder.add(&quot;(source, $L&quot;, binding.getId().code);</div><div class="line">            if (fieldBinding.isRequired() || requiresCast) &#123;</div><div class="line">                builder.add(&quot;, $S&quot;, asHumanDescription(singletonList(fieldBinding)));</div><div class="line">            &#125;</div><div class="line">            if (requiresCast) &#123;</div><div class="line">                builder.add(&quot;, $T.class&quot;, fieldBinding.getRawType());</div><div class="line">            &#125;</div><div class="line">            builder.add(&quot;)&quot;);</div><div class="line">        &#125;</div><div class="line">        result.addStatement(&quot;$L&quot;, builder.build());</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    List&lt;MemberViewBinding&gt; requiredBindings = binding.getRequiredBindings();</div><div class="line">    if (requiredBindings.isEmpty()) &#123;</div><div class="line">        result.addStatement(&quot;view = source.findViewById($L)&quot;, binding.getId().code);</div><div class="line">    &#125; else if (!binding.isBoundToRoot()) &#123;</div><div class="line">        result.addStatement(&quot;view = $T.findRequiredView(source, $L, $S)&quot;, UTILS,</div><div class="line">                binding.getId().code, asHumanDescription(requiredBindings));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    addFieldBinding(result, binding);</div><div class="line">    // OnClick 等监听事件绑定</div><div class="line">    addMethodBindings(result, binding);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，整个 <code>ButterKnifeProcessor</code> 解析注解、生成 Java 代码的流程就走完了。</p>
<p>这时我们就把整个ButterKnife的代码分析完了，来复习一下:首先我们在代码中为某个元素添加注解，然后编译，ButterKnifeProcessor会在编译前对我们添加的注解进行解析，并生成对应的java源文件。然后编译器开始编译所有的java源文件。运行的时候，我们首先执行ButterKnife.bind()方法，bind方法内部获取到对应viewbinding类的构造方法，并且借此创建出对应的对象实例，在创建的过程中也就是构造方法里，执行了注入的代码。注入完成后，我们的代码里就可以直接使用被注解修饰过的变量了。</p>
<p>ButterKnife就是这样一个优秀的基于编译期注解的注入框架，类似的框架还有Dagger2、AndroidAnnotations等。这些框架都为开发工作带来了极大的方便。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/04/21/ButterKnife-源码分析/" class="archive-article-date">
  	<time datetime="2017-04-21T07:14:38.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-04-21</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
  
    <a href="/2017/03/08/Android-NDK中armeabi和armeabi-v7，armeabi64-v8a的区别/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title"></div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>




<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
	    <a class="jiathis_button_twitter"></a>
	    <a class="jiathis_button_plus"></a> 
	    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="//v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>









      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 fkaking
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				
    			</div>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">苟利国家生死已&lt;br&gt;岂因祸福避趋之</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>